{
  "id": "73425127-e29f-4e6d-b1bd-6dbb2e950e1e",
  "jobName": "Funções Auxíliares",
  "connection": "source",
  "selectSql": "-- Texto to Date\nCREATE OR REPLACE FUNCTION public.text_to_date(p_txt text)\nRETURNS date\nLANGUAGE plpgsql\nAS $$\nDECLARE\n  v text;\n  d date;\nBEGIN\n  v := btrim(p_txt);\n\n  -- nulos / vazios / lixo comum\n  IF v IS NULL OR v = '' THEN\n    RETURN NULL;\n  END IF;\n\n  v := regexp_replace(v, '\\s+', ' ', 'g'); -- normaliza espaços\n  IF lower(v) IN ('null', 'nil', 'none', 'n/a', 'na') THEN\n    RETURN NULL;\n  END IF;\n\n  -- pega só a parte da data caso venha junto com hora (ex: \"2026-02-20 08:37:44\")\n  v := split_part(v, ' ', 1);\n\n  BEGIN\n    -- 2026-02-20\n    IF v ~ '^\\d{4}-\\d{2}-\\d{2}$' THEN\n      d := to_date(v, 'YYYY-MM-DD');\n\n    -- 20-02-2026\n    ELSIF v ~ '^\\d{2}-\\d{2}-\\d{4}$' THEN\n      d := to_date(v, 'DD-MM-YYYY');\n\n    -- 20/02/2026\n    ELSIF v ~ '^\\d{2}/\\d{2}/\\d{4}$' THEN\n      d := to_date(v, 'DD/MM/YYYY');\n\n    -- 2026/02/20\n    ELSIF v ~ '^\\d{4}/\\d{2}/\\d{2}$' THEN\n      d := to_date(v, 'YYYY/MM/DD');\n\n    -- 20260220\n    ELSIF v ~ '^\\d{8}$' THEN\n      d := to_date(v, 'YYYYMMDD');\n\n    -- 20022026 (se existir na base; pode ser ambíguo com MMDDYYYY)\n    ELSIF v ~ '^\\d{8}$' AND substring(v, 1, 2)::int BETWEEN 1 AND 31 THEN\n      d := to_date(v, 'DDMMYYYY');\n\n    ELSE\n      RETURN NULL;\n    END IF;\n\n  EXCEPTION WHEN others THEN\n    RETURN NULL;\n  END;\n\n  -- opcional: invalidar datas absurdas (ajuste se quiser)\n  IF d \u003c date '1900-01-01' OR d \u003e date '2100-12-31' THEN\n    RETURN NULL;\n  END IF;\n\n  RETURN d;\nEND;\n$$;\n\n\n-- Texto to Timestamp\nCREATE OR REPLACE FUNCTION public.text_to_timestamp(p_txt text)\nRETURNS timestamp\nLANGUAGE plpgsql\nAS $$\nDECLARE\n  v text;\n  ts timestamp;\n  tz timestamptz;\n  frac text;\nBEGIN\n  v := btrim(p_txt);\n\n  IF v IS NULL OR v = '' THEN\n    RETURN NULL;\n  END IF;\n\n  v := regexp_replace(v, '\\s+', ' ', 'g');\n  IF lower(v) IN ('null', 'nil', 'none', 'n/a', 'na') THEN\n    RETURN NULL;\n  END IF;\n\n  -- aceita ISO com T\n  v := replace(v, 'T', ' ');\n\n  BEGIN\n    -- Epoch: milissegundos (13 dígitos)\n    IF v ~ '^\\d{13}$' THEN\n      ts := to_timestamp((v::bigint / 1000.0));\n\n    -- Epoch: segundos (10 dígitos)\n    ELSIF v ~ '^\\d{10}$' THEN\n      ts := to_timestamp(v::bigint);\n\n    -- YYYY-MM-DD HH:MI:SS(.ffffff)? (sem TZ)\n    ELSIF v ~ '^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}(\\.\\d{1,6})?$' THEN\n      ts := to_timestamp(v, 'YYYY-MM-DD HH24:MI:SS');\n\n    -- DD-MM-YYYY HH:MI:SS(.ffffff)?\n    ELSIF v ~ '^\\d{2}-\\d{2}-\\d{4} \\d{2}:\\d{2}:\\d{2}(\\.\\d{1,6})?$' THEN\n      ts := to_timestamp(v, 'DD-MM-YYYY HH24:MI:SS');\n\n    -- YYYY/MM/DD HH:MI:SS(.ffffff)?\n    ELSIF v ~ '^\\d{4}/\\d{2}/\\d{2} \\d{2}:\\d{2}:\\d{2}(\\.\\d{1,6})?$' THEN\n      ts := to_timestamp(v, 'YYYY/MM/DD HH24:MI:SS');\n\n    -- DD/MM/YYYY HH:MI:SS(.ffffff)?\n    ELSIF v ~ '^\\d{2}/\\d{2}/\\d{4} \\d{2}:\\d{2}:\\d{2}(\\.\\d{1,6})?$' THEN\n      ts := to_timestamp(v, 'DD/MM/YYYY HH24:MI:SS');\n\n    -- YYYYMMDD HH:MI:SS(.ffffff)?\n    ELSIF v ~ '^\\d{8} \\d{2}:\\d{2}:\\d{2}(\\.\\d{1,6})?$' THEN\n      ts := to_timestamp(v, 'YYYYMMDD HH24:MI:SS');\n\n    -- sem segundos: YYYY-MM-DD HH:MI(.ffffff)?\n    ELSIF v ~ '^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}(\\.\\d{1,6})?$' THEN\n      ts := to_timestamp(v, 'YYYY-MM-DD HH24:MI');\n\n    -- sem segundos: DD/MM/YYYY HH:MI\n    ELSIF v ~ '^\\d{2}/\\d{2}/\\d{4} \\d{2}:\\d{2}(\\.\\d{1,6})?$' THEN\n      ts := to_timestamp(v, 'DD/MM/YYYY HH24:MI');\n\n    -- só data (vira 00:00:00)\n    ELSIF v ~ '^\\d{4}-\\d{2}-\\d{2}$' THEN\n      ts := to_timestamp(v, 'YYYY-MM-DD');\n    ELSIF v ~ '^\\d{2}/\\d{2}/\\d{4}$' THEN\n      ts := to_timestamp(v, 'DD/MM/YYYY');\n    ELSIF v ~ '^\\d{8}$' THEN\n      ts := to_timestamp(v, 'YYYYMMDD');\n\n    -- ISO / formatos com timezone (Z, -03, -03:00, +0000 etc.)\n    ELSIF v ~ '.*(Z|[+-]\\d{2}(:?\\d{2})?)$' THEN\n      -- tenta parsing nativo do Postgres\n      tz := v::timestamptz;\n      ts := tz::timestamp;\n\n    ELSE\n      RETURN NULL;\n    END IF;\n\n    -- Se tiver fração de segundos, preservar (to_timestamp pode ignorar em alguns casos)\n    -- Estratégia simples: se existir \".digits\" e ainda não estiver no ts, soma intervalo.\n    IF v ~ '\\.\\d{1,6}' THEN\n      frac := regexp_replace(v, '.*\\.(\\d{1,6}).*', '\\1');\n      frac := rpad(frac, 6, '0');\n      ts := date_trunc('second', ts) + (frac::int * interval '1 microsecond');\n    END IF;\n\n  EXCEPTION WHEN others THEN\n    RETURN NULL;\n  END;\n\n  -- opcional: invalidar timestamp absurdo\n  IF ts \u003c timestamp '1900-01-01 00:00:00' OR ts \u003e timestamp '2100-12-31 23:59:59' THEN\n    RETURN NULL;\n  END IF;\n\n  RETURN ts;\nEND;\n$$;\n",
  "insertSql": "",
  "columns": [],
  "primaryKeys": null,
  "recordsPerPage": 1000,
  "type": "execution",
  "stopOnError": true,
  "left": 500,
  "top": -960
}